#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "questions.h"

Node * get_list_from_file (char *input_file_name) {
    Node * head = NULL;
    char line[MAX_LINE];
    
    // open input file
    FILE *f = fopen(input_file_name, "r");
        if (!f){
        perror(input_file_name);
        exit(1);
    }
    
    // keep track of the last node in the linked list 
    // (since we insert at the end)
    Node *end = head;
    
    // read lines and add to the list
    while (fgets(line, MAX_LINE, f) != NULL){
        // remove end-of-line characters
        line[strcspn(line, "\r\n")] = '\0';
        
        // create new node
        Node *new = malloc(sizeof(Node));
        if (!new){
            perror("malloc");
            exit(1);
        }
        
        char *newstr = malloc((strlen(line)+1)*sizeof(char));
        if (!newstr){
            perror("malloc");
            exit(1);
        }
        strcpy(newstr, line);
        
        new->str = newstr;
        new->next = NULL;
        
        // add node to end of linked list
        if (!end){ // empty list
            head = new;
            end = head;
            
        } else {
            end->next = new;
            end = new;
        }
    }
    
    fclose(f);
    
    return head;
}

void print_list (Node *head) {
    // we use head as pointer to each successive node in the list
    for (; head; head = head->next)
        printf("%s\n", head->str);
}

void free_list (Node *head) {
    Node *next;

    // we use head as pointer to each successive node in the list    
    for (; head; head = next){
        // we need to keep track of the next pointer, since we cannot
        // access it through head once head has been freed
        next = head->next; 
        
        // free the node string
        free(head->str);
        // free the node itself
        free(head);
    }
}

#ifndef QUESTIONS_H
#define QUESTIONS_H

#define MAX_LINE 256

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct str_node {
	char *str;
	struct str_node *next;
} Node;

Node * get_list_from_file (char *input_file_name);
void print_list (Node *current);
void free_list (Node *head);

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "utils.h"

/*
 * Print a formatted error message to stderr.
 */
void error(char *msg) {
    fprintf(stderr, "Error: %s\n", msg);
}

int validate_answer(char *answer,int clientfd){
    char *invalid_message = "ERROR: Answer must be one of 'y', 'n', 'quit'.\n";

    if (strlen(answer) > 10){
        printf("%s", invalid_message);
        return 2;
    }

    if (answer[0] == 'q' || answer[0] == 'Q')
        return -1;

    if (answer[0] == 'n' || answer[0] == 'N')
        return 0;

    if (answer[0] == 'y' || answer[0] == 'Y')
        return 1;
    char buf[MAX_LINE];
    sprintf(buf,"%sanswer : %s\n", invalid_message,answer);
    send_text(clientfd,buf);
    return 2;
}

/*
 * Read and process commands
 */
int process_args(int cmd_argc, char **cmd_argv, QNode **root, Node *interests,
		 struct client *current_client, struct client *head) {
	QNode *qtree = *root;
	if (cmd_argc <= 0) {
		return 0;

	} else if (strcmp(cmd_argv[0], "quit") == 0 && cmd_argc == 1) {
		/* Return an appropriate value to denote that the specified
		 * user is now need to be disconnected. */
		return -1;

	} else if (strcmp(cmd_argv[0], "do_test") == 0 && cmd_argc == 1) {
		/* The specified user is ready to start answering questions. You
		 * need to make sure that the user answers each question only
		 * once.
		 */
         int check = do_test(root, interests,current_client,head);
         //current_client -> state = check;
         return check;

	} else if (strcmp(cmd_argv[0], "get_all") == 0 && cmd_argc == 1) {
		/* Send the list of best mismatches related to the specified
		 * user. If the user has not taked the test yet, return the
		 * corresponding error value (different than 0 and -1).
		 */
         get_opposite(current_client->username,
                qtree,current_client->fd,question_num(interests));


	} else if (strcmp(cmd_argv[0], "post") == 0 && cmd_argc == 3) {
		/* Send the specified message stored in cmd_argv[2] to the user
		 * stored in cmd_argv[1].
		 */
         client * target = find_client(cmd_argv[1],&head);
         if(target == NULL){
             send_text(current_client->fd,"No such user on line\n");
             return 0;
         }
         else{
             char conversation[MAX_LINE];
             sprintf(conversation,"Message from %s : %s\n",current_client->username,cmd_argv[2]);
             send_text(target->fd,conversation);
         }
	}
	else {
		/* The input message is not properly formatted. */
		send_text(current_client->fd,"Invalid command\n");
	}
	return 0;
}


// -1 for quit,  1 for done
int do_test(QNode **root, Node *interests,
            struct client *current_client, struct client *head){

    QNode * qtree = *root;

    Node * user_list = find_user(qtree,current_client->username);

    char buf[MAX_LINE];
    char buf2[MAX_LINE];
    char answer[MAX_LINE];
    int inbuf = 0;
    int clientfd = current_client->fd;
    //printf("Your user name : %s\n",current_client->username);
    if(user_list != NULL){
        //printf("Client fd :%d\n",clientfd);
        send_text(current_client->fd,"You already done the test\n");
        return 1;
    }
    if(user_list == NULL){
        QNode * prev,*curr;
        prev = curr = qtree;
        // collecting your interests :
        send_text(clientfd,"collecting your interests\n");


        // set up reading structure
        char * after = buf + inbuf;
        int room = sizeof(buf) - inbuf;
        int nbytes,where;
        // iterate over list of interests
        Node *i = interests;
        int ans;
        while(i != NULL){
            // should send the question to the client

            bzero(buf2,MAX_LINE);
            sprintf(buf2,"do you like %s?\n",i->str);
            send_text(clientfd,buf2);

            // should read the answer from the client
            while(1){
                if((nbytes = read(clientfd,after,room)) > 0){
                    inbuf += nbytes;
                    where = find_network_newline(buf,inbuf);
                    if(where >= 0){
                        buf[where] = '\0';
                        buf[where + 1] = '\0';
                        bzero(answer,MAX_NAME);
                        strncpy(answer,buf,where);
                        where += 2;
                        inbuf -= where;
                        memmove(buf,buf+where,inbuf);
                        // validate the username
                        if(strlen(answer) == 0){
                            room = sizeof(buf) - inbuf;
                            after = buf + inbuf;
                            continue;
                        }

                        ans = validate_answer(answer,clientfd);
                        //printf("I get your answer : %d\n",ans);
                        // if 1: find branch
                        // if 0: find branch
                        // if 2: print invalid_message
                        // if -1: ready to quit
                        if(ans == -1){
                            //printf("quiting\n");
                            // should remove the client from the list outside
                            return -1;
                        }
                        if(ans == 2){
                            room = sizeof(buf) - inbuf;
                            after = buf + inbuf;
                            break;
                        }

                        prev = curr;
                        curr = find_branch(curr,ans);
                        i = i->next;
                        room = sizeof(buf) - inbuf;
                        after = buf + inbuf;
                        break;

                    }
                    room = sizeof(buf) - inbuf;
                    after = buf + inbuf;
                }
                else if(nbytes == 0){
                    //printf("client Disconnect\n");
                    return -1;
                    break;
                }
            }

        }
        prev->children[ans].fchild =
            add_user(prev->children[ans].fchild,current_client->username);
        // should use find answer and update the answer of the client
        current_client->answers = get_answer(current_client->username,qtree,question_num(interests));
        send_text(clientfd,"Test Complete\n");
    }

    return 1;


}

/*
 * Tokenize the command stored in cmd.
 * Return the number of tokens, and store the tokens in cmd_argv.
 */
int tokenize(char *cmd, char **cmd_argv) {
    int cmd_argc = 0;
    char *next_token = strtok(cmd, DELIM);

    while (next_token != NULL) {
        cmd_argv[cmd_argc] = next_token;
        ++cmd_argc;

	if(cmd_argc < (INPUT_ARG_MAX_NUM - 1))
	    next_token = strtok(NULL, DELIM);
	else
	    break;
    }

    if (cmd_argc == (INPUT_ARG_MAX_NUM - 1)) {
	cmd_argv[cmd_argc] = strtok(NULL, "");
	if(cmd_argv[cmd_argc] != NULL)
	    ++cmd_argc;
    }

    return cmd_argc;
}


int find_network_newline(char *buf,int inbuf){
    int i;
    for (i = 0;i<inbuf -1;i++){
        if ((buf[i] == '\r') && (buf[i+1] == '\n')){
            return i;
        }
    }
    return -1;
}

int question_num(Node * head){
    Node * cur = head;
    int result = 0;
    while(cur != NULL){
        result ++;
        cur = cur->next;
    }
    return result;
}

int * get_answer(char * username,QNode * root,int q_num){
    QNode * cur;
    Node * check;
    cur = root;
    check = find_user(cur,username);

    if(!check){
        return NULL;
    }

    int * result = (int*)calloc(q_num,sizeof(int));
    int index = 0;

    while(cur->node_type != LEAF){
        check = find_user(cur->children[0].qchild,username);
        if (check == NULL){
            result[index] = 1;
            cur = cur->children[1].qchild;
            index ++;
        }
        else{
            result[index] = 0;
            cur = cur->children[0].qchild;
            index ++;
        }
    }
    if(find_user(cur,username) == cur->children[0].fchild){
        result[index] = 0;
    }
    else{
        result[index] = 1;
    }
    return result;
}

void send_text(int clientfd,char* msg){
    char buf[MAX_LINE];
    sprintf(buf,"%s",msg);
    int len;
    if((len = write(clientfd,buf,strlen(buf))) !=strlen(buf)){
        perror("writing");
        exit(1);
    }
}

int disconnect_client(char*username,client**addr_online_clients){
    client * head = *addr_online_clients;
    client * previous = NULL;
    while(head != NULL){
        if(strcmp(username,head->username) == 0){
            if(previous == NULL){
                free_one_client(head->username,*addr_online_clients);
                *addr_online_clients = NULL;
                return 0;
            }
            else{
                previous->next = head->next;
                free_one_client(head->username,*addr_online_clients);
                return 0;
            }
        }
        previous = head;
        head = head->next;

    }
    return 1;
}

void free_one_client(char * username,client * connected){
    client * this_client = find_client(username,&connected);
    if(this_client != NULL){
        close(this_client->fd);
        free(this_client->answers);
        free(this_client);
    }
}

client * find_client(char*username,client**online_clients){
    client* head = *online_clients;
    client * target = NULL;

    while(head != NULL){
        if(strcmp(head->username,username) == 0){
            return head;
            break;
        }
        head = head->next;
    }
    return target;
}

client* find_client_byfd(int clientfd,client**online_clients){
    client* head = *online_clients;
    client * target = NULL;
    while(head != NULL){
        if(head->fd == clientfd){
            target = head;
            break;
        }
        head = head->next;
    }
    return target;
}

// new part
Node * get_opposite(char *username,QNode * root,int clientfd,int q_num){
    QNode * cur;
    Node * check;
    cur = root;
    check = find_user(cur,username);
    Node * result = NULL;
    if(!check){
        send_text(clientfd,"You have to do the test first\n");
        return result;
    }

    int * answer = get_answer(username,root,q_num);
    int index = 0;
    while(cur->node_type != LEAF){
        cur = find_branch(cur,1-answer[index]);
        index ++;
    }

    result = cur->children[1-answer[index]].fchild;
    char*no = "No completing personality found please try again later\n";
    if(result == NULL){
        send_text(clientfd,no);
        return result;
    }

    char*yes = "Here are your best mismatches:\n";
    send_text(clientfd,yes);
    check = result;
    char namebuf[MAX_NAME];
    while(check != NULL){
        sprintf(namebuf,"%s\n",check->str);
        send_text(clientfd,namebuf);
        check = check->next;
    }
    send_text(clientfd,"\n");
    return result;
}

#ifndef _UTILS_H
#define _UTILS_H

#include <netinet/in.h>
#include "qtree.h"
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <ctype.h>

#define MAX_NAME 128
#define INPUT_ARG_MAX_NUM 3
#define DELIM " \r\n"

/*
 * Τhe definition of the following structure is copied directly from the
 * muffinman server (http://www.cdf.toronto.edu/~ajr/209/a4/muffinman.c).
 * You might need to add more fields - such as a seoarate buffer for each client and
 * the current position in the buffer - as explained in A 4 handout.
 */
typedef struct client {
    int fd;
    int * answers;
    // 0->name   1->done_question -1->log_out
    int state;
    char buf[MAX_LINE];
    int inbuf;
    struct in_addr ipaddr;
    char username[MAX_NAME];
    struct client *next;
} client;

/*
 * Print a formatted error message to stderr.
 */
void error(char *);
int validate_answer(char *answer,int clientfd);
int find_network_newline(char *buf,int inbuf);
int question_num(Node * head);
int * get_answer(char *username, QNode * root, int q_num);
int do_test(QNode **root, Node *interests,
            struct client *current_client, struct client *head);
void send_text(int clientfd,char* msg);

int disconnect_client(char*username,client**addr_online_clients);
void free_one_client(char * username,client * connected);
client * find_client(char*username,client**online_clients);
Node * get_opposite(char *username,QNode * root,int clientfd,int q_num);
/*
 * Read and process commands
 */
int process_args(int, char **, QNode **, Node *, struct client *, struct client *);
client* find_client_byfd(int clientfd,client**online_clients);

/*
 * Tokenize the string stored in cmd.
 * Return the number of tokens, and store the tokens in cmd_argv.
 */
int tokenize(char *, char **);

#endif /* _UTILS_H */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include "utils.h"

#ifndef PORT
    #define PORT 57988
#endif



int validate_user(char *name);
// shan
int get_username(char *name, int clientfd);
int add_client(char*username,client* online_clients,int c_fd,struct in_addr c_addr,int q_num);
client * a_new_client(char*username,int c_fd,struct in_addr c_addr,int q_num);
int online_num(client*online_clients);
char ** cmd_initializer(int len);



QNode *root = NULL;
Node *interests = NULL;
client * connected = NULL;

char *user_prompt = "What is your name?\n";
char *welcome = "Welcome.\n";
char *what_to_do = "Go ahead and enter user commands>\n";
char *question_prompt = "Do you like %s? (y/n)\n";
char *neg_result = "Sorry, no users with similar interests joined yet\n\n";
char *pos_result1 = "friend recommendation for user %s:\n";
char *pos_result2 = "You have total %d potential friend(s)!!!\n\n";

int main (int argc, char **argv) {

    // ============== initialize all the overall variables
    char name[MAX_NAME];
    int q_num;


    // ============== check the number of command line arguments
    if (argc < 2) {
        printf ("To run the program ./categorizer <name of input file>\n");
        return 1;
    }

    // ============== read interests from file and built question tree
    interests = get_list_from_file (argv[1]);
    q_num = question_num(interests);
    if (interests == NULL)
        return 1;
    root = add_next_level (root,  interests);
   // ============== initialize the server and client socket
    /////////////////////////////////////////////////////////////////////////////////////////////////
/* master file descriptor list */
fd_set master;
/* temp file descriptor list for select() */
fd_set read_fds;
int fdmax;
FD_ZERO(&master);
FD_ZERO(&read_fds);
/////////////////////////////////////////////////////////////////////////////////////////////////

    // ============== initialize the server and client socket
    int parentfd,clientfd;
    socklen_t clientlen;
    struct sockaddr_in serveraddr,clientaddr;
    char buf[MAX_LINE];
    int inbuf = 0;
    int port = (int) PORT;
    struct hostent *hostp;
    char*hostaddrp;
    int on = 1,status;

    // socket and status
    if((parentfd = socket(AF_INET,SOCK_STREAM,0))< 0){
        perror("socket");
        exit(1);
    }

    status = setsockopt(parentfd,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on) );
    if(status == -1){
        perror("socketopt -- REUSEADDR");
        exit(1);
    }

    bzero((char*)&serveraddr,sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
    // port from command line so that easy to debug,. need to clean after use
    serveraddr.sin_port = htons(port);

    // bind and listen
    if (bind(parentfd,(struct sockaddr *)&serveraddr,sizeof serveraddr) < 0){
        perror("bind");
        exit(1);
    }
    if (listen(parentfd,5)){
        perror("listen");
        exit(1);
    }

    printf("Listening on %d\n",port);
/////////////////////////////////////////////////////////////////////////////////////////////
FD_SET(parentfd, &master);
fdmax = parentfd;
/////////////////////////////////////////////////////////////////////////////////////////////



    // ============================== main application loop
    clientlen = sizeof clientaddr;
    client * current_client = NULL;
    char ** cmd;
    int clean = 0;

    for (; ;){
///////////////////////////////////////////////////////////////////////////////////////
        current_client = NULL;
        read_fds = master;
        if(select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1){
            perror("Server-select() error lol!");
            exit(1);
        }
        for(int i = 0; i <= fdmax; i++){
            if(FD_ISSET(i, &read_fds)){ /* we got one... */
                if(i == parentfd){
                    // accepting a client
                    if((clientfd = accept(parentfd,(struct sockaddr *)&clientaddr,&clientlen)) < 0){
                        perror("accept");
                        exit(1);
                    }
                    else{
                        // print the client which server established connetction with
                        hostp = gethostbyaddr((const char*)&clientaddr.sin_addr.s_addr,
                                sizeof(clientaddr.sin_addr.s_addr),AF_INET);
                        if(hostp == NULL){
                            perror("gethostbyaddr");
                            exit(1);
                        }
                        hostaddrp = inet_ntoa(clientaddr.sin_addr);
                        if(hostaddrp == NULL){
                            perror("inet_ntoa");
                            exit(1);
                        }
                        printf("Connection from %s %s\n",
                        hostp->h_name,hostaddrp);

                        FD_SET(clientfd, &master);
                        if(clientfd>fdmax){
                            fdmax = clientfd;
                        }
                        send_text(clientfd,user_prompt);
                        clean = get_username(name,clientfd);
                        if (clean == -1){
                            close(clientfd);
                            printf("Removeing connection from %s\n",inet_ntoa(clientaddr.sin_addr));
                            continue;
                        }
                        printf("Adding client %s\n",inet_ntoa(clientaddr.sin_addr));
                        if(connected == NULL){
                            connected = a_new_client(name,clientfd,clientaddr.sin_addr,q_num);
                        }
                        else if(connected != NULL && find_client(name,&connected) == NULL){
                            add_client(name,connected,clientfd,clientaddr.sin_addr,q_num);
                        }
                        current_client = find_client(name,&connected);
                        // update fd
                        current_client->fd = clientfd;
                        // asking what to do
                        send_text(clientfd,welcome);
                        send_text(clientfd,what_to_do);
                    }
//////////////////////////////////////////////////////////////////////////////////////////////
                // accepting a client


            }

            else{

                //////////////////////////////////////////////////
                    // get a valid username , check whether it's quit

                    current_client = find_client_byfd(i,&connected);
                    clientfd = i;
                    // for test : passed
                    //printf("Received username : %s\n", current_client->username);



                    // can do multiple commands
                    while(1){

                        cmd = cmd_initializer(MAX_LINE);
                        bzero(buf,MAX_LINE);
                        inbuf = 0;
                        char * after = buf + inbuf;
                        int room = sizeof(buf) - inbuf;
                        int nbytes,where;
                        char container[MAX_LINE];
                        // go out until get a complete command line
                        int terminate_cmd = 0;
                        sleep(1);
                        while(1){
                            // receive user commands
                            if((nbytes = read(clientfd,after,room)) > 0){
                                inbuf += nbytes;
                                where = find_network_newline(buf,inbuf);
                                if(where >= 0){
                                    buf[where] = '\0';
                                    buf[where + 1] = '\0';
                                    bzero(container,MAX_NAME);
                                    strncpy(container,buf,where);
                                    where += 2;
                                    inbuf -= where;
                                    memmove(buf,buf+where,inbuf);
                                    if(strlen(container) != 0){
                                        break;
                                    }
                                }
                                room = sizeof(buf) - inbuf;
                                after = buf + inbuf;
                            }
                            else if(nbytes == 0){
                                terminate_cmd = -1;
                                break;
                            }
                        }

                    if(terminate_cmd == -1){
                        FD_CLR(clientfd,&master);
                        printf("Removeing connection from %s\n",inet_ntoa(current_client->ipaddr));
                        disconnect_client(current_client->username,&connected);
                        break;
                    }
                    sleep(1);
                    // hanged process user commands
                    cmd = cmd_initializer(MAX_LINE);
                    int cmd_num = tokenize(container,cmd);
                    terminate_cmd = process_args(cmd_num, cmd, &root, interests,current_client, connected);
                    printf("recorded activity for %s\n",current_client->username);
                    if(terminate_cmd == -1){
                        FD_CLR(clientfd,&master);
                        printf("Removeing connection from %s\n",inet_ntoa(current_client->ipaddr));
                        disconnect_client(current_client->username,&connected);
                        break;
                    }
                    send_text(clientfd,what_to_do);
                    break;
                }


            }
}
}
}

    return 0;
}










// =============================


// 0 for valid, -1 for quit
int get_username(char *name, int clientfd){
    char buf[MAX_LINE];
    int inbuf = 0;
    // write user_prompt


    bzero(name,MAX_NAME);

    //
    char *after = buf + inbuf;
    int room = sizeof(buf) - inbuf;
    int nbytes,where;

    while(1){
        if((nbytes = read(clientfd,after,room)) > 0){
            inbuf += nbytes;
            where = find_network_newline(buf,inbuf);
            if(where >= 0){
                buf[where] = '\0';
                buf[where + 1] = '\0';
                bzero(name,MAX_NAME);
                strncpy(name,buf,where);
                where += 2;
                inbuf -= where;
                memmove(buf,buf+where,inbuf);
                // validate the username
                int check = validate_user(name);
                if(check == 1){
                    break;
                }
                if(check == -1){
                    return -1;
                    // should remove the client from the linked list
                }
                send_text(clientfd,"Invalid username, please try  another: \n");
            }
            room = sizeof(buf) - inbuf;
            after = buf + inbuf;
        }
        else if(nbytes == 0){
            //printf("client Disconnection 2\n");
            return -1;
            break;
        }

        // clean buf and  read user name, and add the user

    }
    return 0;
}


// =============================













int validate_user(char *name){
    int valid = 1;

    int len = strlen(name);
    if (len < 8 || len > 128){
        valid = 0;
    }

    for (int i = 0; i < len; i++){
        if (!isalnum(name[i])){
            valid = 0;
            break;
        }
    }

    if(strcmp(name,"quit") == 0){
        valid = -1;
    }
    return valid;
}





// ============================= shan




client * a_new_client(char*username,int c_fd,struct in_addr c_addr,int q_num){
    client * new_client = (client*)calloc(1,sizeof(client));
    new_client->next = NULL;
    new_client->fd = c_fd;
    new_client->ipaddr = c_addr;
    new_client->state = 0;
    new_client->inbuf = 0;
    new_client->answers = (int*)calloc(q_num,sizeof(int));
    strncpy(new_client->username,username,strlen(username));
    return new_client;
}

int add_client(char*username,client* online_clients,int c_fd,struct in_addr c_addr,int q_num){
    client * head = online_clients;

    while(head->next != NULL){
        if(strcmp(head->username,username) == 0){
            return 0;
        }
        head = head->next;
    }
    client * new_client = (client*)calloc(1,sizeof(client));
    new_client->next = NULL;
    new_client->fd = c_fd;
    new_client->ipaddr = c_addr;
    new_client->state = 0;
    new_client->inbuf = 0;
    new_client->answers = (int*)calloc(q_num,sizeof(int));
    strncpy(new_client->username,username,strlen(username));
    head->next = new_client;
    return 1;
}



int online_num(client*online_clients){
    client * head = online_clients;
    int result = 0;
    while(head != NULL){
        result ++;
        head = head->next;
    }
    return result;
}

char ** cmd_initializer(int len){
    char ** cmd = (char **) calloc(len,sizeof(char*));
    for(int i=0;i<len;i++){
        cmd[i] = (char *)calloc(len,sizeof(char));
    }
    return cmd;
}



// ================= new part

CC = gcc
CFLAGS = -Wall -std=c99 -g
PORT = 57988
CFLAGS += -DPORT=\$(PORT)

all: mismatch_server

mismatch_server: qtree.c questions.c utils.c categorizer.c
	$(CC) $(CFLAGS) qtree.c questions.c categorizer.c utils.c -o mismatch_server

clean:
	rm mismatch_server

#include "qtree.h"

QNode *add_next_level (QNode *current, Node *list_node) {
    int str_len;
    
    str_len = strlen (list_node->str);
    current = (QNode *) calloc (1, sizeof(QNode));

    current->question =  (char *) calloc (str_len +1, sizeof(char ));
    strncpy ( current->question, list_node->str, str_len );
    current->question [str_len] = '\0';  
    current->node_type = REGULAR;
    
    if (list_node->next == NULL) {
        current->node_type = LEAF;
        return current;
    }
    
    current->children[0].qchild = add_next_level ( current->children[0].qchild, list_node->next);
    current->children[1].qchild = add_next_level ( current->children[1].qchild, list_node->next);

    return current;
}

void print_qtree (QNode *parent, int level) {
    int i;
    for (i=0; i<level; i++)
        printf("\t");
    
    printf ("%s type:%d\n", parent->question, parent->node_type);
    if(parent->node_type == REGULAR) {
        print_qtree (parent->children[0].qchild, level+1);
        print_qtree (parent->children[1].qchild, level+1);
    }
    else { //leaf node
        for (i=0; i<(level+1); i++)
            printf("\t");
        print_users (parent->children[0].fchild);
        for (i=0; i<(level+1); i++)
            printf("\t");
        print_users (parent->children[1].fchild);
    }
}

void print_users (Node *parent) {
    if (parent == NULL)
        printf("NULL\n");
    else {
        printf("%s, ", parent->str);
        while (parent->next != NULL) {
            parent = parent->next;
            printf("%s, ", parent->str);
        }
        printf ("\n");
    }
}

// find the branch that answer corresponds to, starting from
// node current
QNode *find_branch(QNode *current, int answer){
    return current->children[answer].qchild;   
}

// add user to the end of the user list and return the list
Node *add_user(Node *head, char *user){
    // create a new user node    
    Node *new = malloc(sizeof(Node));
    if (!new){
        perror("malloc");
        exit(1);
    }
    
    char *newstr = malloc((strlen(user)+1)*sizeof(char));
    if (!newstr){
        perror("malloc");
        exit(1);
    }
    strcpy(newstr, user);
        
    new->str = newstr;
    new->next = NULL;
    
    // list is empty
    if (!head){
        head = new;
    
    } else {
        // find the end of the list
        Node *current;
        for (current = head; current->next; current = current->next);
        
        current->next = new;
    }
    
    return head;
}

// find a user in the tree
// return NULL if the user was not found
Node *find_user(QNode *current, char *name){
    // current is an inner node
    if (current->node_type == REGULAR){
        
        Node *head;
        // look for the node (recursively) in the 0 subtree
        head = find_user(current->children[0].qchild, name);
        if (head)
            return head;
            
        // look for the node (recursively) in the 1 subtree
        head = find_user(current->children[1].qchild, name);
        if (head)
            return head;
            
    // current is a leaf node
    } else {
        // look for the user in the 0 child       
        Node *head = current->children[0].fchild;
        
        while (head != NULL) {
            if (strcmp(head->str, name) == 0)
                return current->children[0].fchild;
            head = head->next;
        }

        // look for the user in the 1 child
        head = current->children[1].fchild;

        while (head != NULL) {
            if (strcmp(head->str, name) == 0)
                return current->children[1].fchild;
            head = head->next;
        }
    }
    
    return NULL;
}

// free tree
void free_qtree(QNode *current){
    if (current){
        if (current->node_type == LEAF){         
            // free lists of users
            free_list(current->children[0].fchild);
            free_list(current->children[1].fchild);
                      
        } else {
            // free left subtree
            free_qtree(current->children[0].qchild);
            // free right subtree
            free_qtree(current->children[1].qchild);
        }
        
        free(current->question); // free question
        free(current);
    }
}

#ifndef QTREE_H
#define QTREE_H
#include "questions.h"

typedef enum {
    REGULAR, LEAF
} NodeType;

union Child {
	struct str_node *fchild;
	struct QNode *qchild;
} Child;

typedef struct QNode {
	char *question;
	NodeType node_type;
	union Child children[2];
} QNode;

QNode *add_next_level (QNode *current, Node * list_node);

void print_qtree (QNode *parent, int level);
void print_users (Node *parent);

Node *add_user(Node *head, char *user);
QNode *find_branch(QNode *current, int answer);
Node *find_user(QNode *current, char *name);
void free_qtree(QNode *root);

#endif
